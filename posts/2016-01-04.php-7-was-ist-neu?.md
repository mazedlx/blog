---
layout: post
title: PHP 7 - Was ist neu?
tag: 
---


                <p>Vor kurzem wurde PHP 7.0.1 veröffentlicht (<a href="http://php.net/archive/2015.php#id2015-12-17-1"><a href="http://php.net/archive/2015.php#id2015-12-17-1">http://php.net/archive/2015.php#id2015-12-17-1</a></a>), und für mich als Webentwickler ist dies Anlass genug um ein paar Zeilen über die Skriptsprache meiner Wahl zu verlieren. <strong>Installation</strong> Mein Webserver läuft mit Ubuntu 14.10, dort habe ich auch die aktuelle Version von PHP kompiliert (aber noch nicht im Einsatz, kommt aber noch). Für die Installation gibt es diverse Leitfäden, ich habe mich an den von Enrico Zimuel gehalten (<a href="http://www.zimuel.it/install-php-7/"><a href="http://www.zimuel.it/install-php-7/">http://www.zimuel.it/install-php-7/</a></a>). Es sei gleich erwähnt dass ich einiges an Paketen nach installieren musste. Wenn dann alles geklappt hat sieht es dann so aus: <img class="alignnone wp-image-8238" style="height: 115px; width: 704px;" src="/uploads/2016/01/php7-zsh.png" alt="php7-zsh" /> <strong>Was ist neu?</strong> Bei einigen Neuerungen kann ich den Nutzen für mich noch nicht ganz sehen, der Großteil der Änderungen ist jedenfall sehr hilfreich. <strong><em>Scalar Type Hinting</em></strong></p>
<pre>&lt;?php
function cube(int $a): int {
    return $a * $a * $a;
}

echo cube(5); // liefert 125
echo cube('a'); // liefert einen Fehler
?&gt;</pre>
<p>Zur Laufzeit überprüft PHP ob der gelieferte Wert dem deklarierten Typ entspricht. Hier gibt es die Möglichkeit eine schwache (mit <code>declare(strict_types=0); </code>, oder durch das Weglassen der Deklaration) oder eine strikte Überprüfung (mit <code>declare(strict_types=1);</code>) anzuwenden. Bei der schwachen  Überprüfung wird versucht den retournierten Wert in den erwarteten Typ zu konvertieren.</p>
<p>&nbsp;</p>
<p><strong><em>Null Coalescing Operator</em></strong></p>
<p>Ein einfaches Beispiel:</p>
<pre>&lt;?php
$id = isset($_GET['id']) ? $_GET['id'] : false;
?&gt;</pre>
<p>In PHP 7 kann dies wie folgt notiert werden:</p>
<pre>&lt;?php
$id = $_GET['id'] ?? false;
?&gt;</pre>
<p>Das ist wesentlich kürzer, und auch einfacher zu lesen. Coalescing kann auch &quot;gechained&quot; werden:</p>
<pre>&lt;?php
$id = $_GET['id'] ?? $_POST['id'] ?? false;
?&gt;</pre>
<p><strong><em>Spaceship Operator</em></strong> Der Spacehip Operator (&lt;=&gt;) wird verwendet um zwei Werte miteinander zu vergleichen, als Rückgabewerte bekommt man -1, 0 oder 1:</p>
<pre>&lt;?php
echo 5 &lt;=--&gt; 5; // 0
echo 5 &lt;=&gt; 6 // -1
echo 5 &lt;=&gt; 4 // 1
?&gt;</pre>
<p>Das klappt auch bei Strings:</p>
<pre>&lt;?php
echo 'a' &lt;=--&gt; 'a'; // 0
echo 'a' &lt;=&gt; 'b' // -1
echo 'b' &lt;=&gt; 'a' // 1
?&gt;</pre>
<p><strong><em>Constant Arrays</em></strong> Array constants können nun mit <code>define()</code> deklariert werden.</p>
<pre>&lt;?php
define('STEAKS',
    [
        'rib-eye',
        'club',
        'porterhouse',
       't-bone'
    ]
);
?&gt;</pre>
<p><strong><em>Anonymous Classes</em></strong> Mit <code>new class</code> kann eine neue Klasse on-the-fly deklariert werden, ideal für Objekte die nicht mehrmals verwendet werden.</p>
<pre>&lt;?php
interface Logger {
    public function log(string $msg);
}

class Application {
    private $logger;

    public function getLogger(): Logger {
         return $this---&gt;logger;
    }

    public function setLogger(Logger $logger) {
         $this-&gt;logger = $logger;
    }
}

$app = new Application;
$app-&gt;setLogger(new class implements Logger {
    public function log(string $msg) {
        echo $msg;
    }
});

var_dump($app-&gt;getLogger());
?&gt;</pre>
<p>Dieses Skript liefert <code>object(class@anonymous)#2 (0) { }</code>   <strong><em>Unicode Codepoint Escape Syntax</em></strong> Nimmt einen Unicode codepoint in hexadezimaler Notation und wandelt ihn in einen UTF-8-String um. Führende Nullen sind optional.</p>
<pre>&lt;?php
echo "u{aa}"; // unterstrichenes a
echo "u{0000aa}"; // wie oben nur mit führenden Nullen
echo "u{9999}";
?&gt;</pre>
<p>So sieht das Ergebnis aus <img class="alignnone wp-image-8247" style="height: 84px; width: 82px;" src="/uploads/2016/01/codepoint.png" alt="codepoint" />   <strong><em>Closure::call()</em></strong> <code>Closure:call()</code>  ist ein kürzerer und performanterer Weg um einen Object Scope an ein Closure zu hängen und einzubinden.</p>
<pre>&lt;?php
class A {
    private $x = 1;
}

// Pre PHP 7 code
$getXCallBack = function() {return $this---&gt;x;};
$getX = $getXCallBack-&gt;bindTo(new A, 'A');
echo $getX();

// PHP 7+ code
$getX = function() {return $this-&gt;x;};
echo $getX-&gt;call(new A);
?&gt;</pre>
<p><strong><em>Filtered unserialize()</em></strong> Sicherheitsverbesserung bei <code>unserialize()</code>. Der Entwickler kann nun angeben welche Objekte erlaubt sind.</p>
<pre>&lt;?php
$data = unserialize($foo, ["allowed_classes" =--&gt; ["MyClass", "MyClass2"]]);
?&gt;</pre>
<p><em><strong>Group use Declarations</strong></em> <code>use</code> Deklarationen können jetzt gruppiert werden</p>
<pre>&lt;?php
// Pre PHP 7 Code
use SomeNameSpaceClass1
use SomeNameSpaceClass2
use SomeNameSpaceClass3

// PHP 7+ Code
use SomeNameSpace{
    Class1,
    Class2,
    Class3
}
?&gt;</pre>
<p><em><strong>Integer division with intdiv()</strong></em> Mit <code>intdiv()</code>wird eine Ganzzahldivision durchgeführt und das Ergebnis zurück gegeben.</p>
<pre>&lt;?php
var_dump(intdiv(10, 3)); // liefert int(3)
?&gt;</pre>
<p><em><strong>Cryptographically Secure Pseudo-Random Number Generator</strong></em> Es gibt 2 neue Funktionen:  <code>string random_bytes ( int $length )</code>  und  <code>int random_int ( int $min , int $max )</code> . Diese liefern kryptographisch sichere Zufallszeichenketten bzw. Zufallszahlen. Besonders bei der Erzeugung von kryptographsichen Schlüsseln oder auch bei Anwendungen wo echte Zufallszahlen benötigt werden (z.B. das Mischen eines Kartendecks) von Interesse.</p>
            
